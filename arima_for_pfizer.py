# -*- coding: utf-8 -*-
"""ARIMA for Pfizer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LFPus4xZRXEk930VVmWotNEbXHSDbhgS
"""

# Commented out IPython magic to ensure Python compatibility.
import warnings
warnings.filterwarnings("ignore")
#Data Manipulation and Treatment
import numpy as np
import pandas as pd
from datetime import datetime
#Plotting and Visualizations
import matplotlib.pyplot as plt
# %matplotlib inline 
import seaborn as sns
from scipy import stats
import itertools
#Scikit-Learn for Modeling
from sklearn import model_selection
from sklearn.ensemble import RandomForestRegressor
from sklearn import metrics
# statistics
from statsmodels.tsa.arima_model import ARIMA
import statsmodels.api as sm
from statsmodels.distributions.empirical_distribution import ECDF
# time series analysis
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

data = pd.read_csv("/content/PFE.csv")
data

data.set_index('Date', inplace=True)
data.index = pd.DatetimeIndex(data.index)

tlen = len(data)-10 #Training data length
train = data[:tlen]
test = data[tlen:]

# General view of the time series data
plt.figure(figsize=(10, 6))
plt.rcParams['axes.unicode_minus'] = False 
data["Close"].plot()
plt.xlabel('Date',fontsize=12,verticalalignment='top')
plt.ylabel('Closing',fontsize=14,horizontalalignment='center')

fig = plt.figure(figsize=(12,8))
ax1=fig.add_subplot(211)
fig = sm.graphics.tsa.plot_acf(data["Close"],lags=20,ax=ax1) #ACF
ax2 = fig.add_subplot(212)
fig = sm.graphics.tsa.plot_pacf(data['Close'],lags=20,ax=ax2) #PACF
plt.show()

sns.set(style = "ticks")# to format into seaborn 
c = '#386B7F' # basic color for plots
plt.figure(figsize = (12, 6))

plt.subplot(411)
cdf = ECDF(train['Close'])
plt.plot(cdf.x, cdf.y, label = "statmodels", color = c);
plt.xlabel('Close'); plt.ylabel('ECDF');

# plot second ECDF  
plt.subplot(412)
cdf = ECDF(train['High'])
plt.plot(cdf.x, cdf.y, label = "statmodels", color = c);
plt.xlabel('High');

# plot second ECDF  
plt.subplot(413)
cdf = ECDF(train['Low'])
plt.plot(cdf.x, cdf.y, label = "statmodels", color = c);
plt.xlabel('Low');

# plot second ECDF  
plt.subplot(414)
cdf = ECDF(train['Open'])
plt.plot(cdf.x, cdf.y, label = "statmodels", color = c);
plt.xlabel('Open');

# Reference from https://www.kaggle.com/pratyushakar/time-series-analysis-using-arima-sarima
from statsmodels.tsa.stattools import adfuller
def test_stationarity(timeseries, window = 12, cutoff = 0.01):

    #Determing rolling statistics
    rolmean = timeseries.rolling(window).mean()
    rolstd = timeseries.rolling(window).std()

    #Plot rolling statistics:
    fig = plt.figure(figsize=(12, 8))
    orig = plt.plot(timeseries, color='blue',label='Original')
    mean = plt.plot(rolmean, color='red', label='Rolling Mean')
    std = plt.plot(rolstd, color='black', label = 'Rolling Std')
    plt.legend(loc='best')
    plt.title('Rolling Mean & Standard Deviation')
    plt.show()
    
    #Perform Dickey-Fuller test:
    print('Results of Dickey-Fuller Test:')
    dftest = adfuller(timeseries, autolag='AIC', maxlag = 20 )
    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])
    for key,value in dftest[4].items():
        dfoutput['Critical Value (%s)'%key] = value
    pvalue = dftest[1]
    if pvalue < cutoff:
        print('p-value = %.4f. The series is likely stationary.' % pvalue)
    else:
        print('p-value = %.4f. The series is likely non-stationary.' % pvalue)
    
    print(dfoutput)

# Reference from https://www.kaggle.com/pratyushakar/time-series-analysis-using-arima-sarima
from scipy import stats
from scipy.stats import normaltest
def residual_plot(model):

    resid = model.resid
    print(normaltest(resid))
    # returns a 2-tuple of the chi-squared statistic, and the associated p-value. the p-value is very small, meaning
    # the residual is not a normal distribution

    fig = plt.figure(figsize=(12,8))
    ax0 = fig.add_subplot(111)

    sns.distplot(resid ,fit = stats.norm, ax = ax0) # need to import scipy.stats

    # Get the fitted parameters used by the function
    (mu, sigma) = stats.norm.fit(resid)

    #Now plot the distribution using 
    plt.legend(['Normal dist. ($\mu=$ {:.2f} and $\sigma=$ {:.2f} )'.format(mu, sigma)], loc='best')
    plt.ylabel('Frequency')
    plt.title('Residual distribution')


    # ACF and PACF
    fig = plt.figure(figsize=(12,8))
    ax1 = fig.add_subplot(211)
    fig = sm.graphics.tsa.plot_acf(model.resid, lags=40, ax=ax1)
    ax2 = fig.add_subplot(212)
    fig = sm.graphics.tsa.plot_pacf(model.resid, lags=40, ax=ax2)

test_stationarity(train['Close'])

closes = train['Close']
first_diff_c = closes - closes.shift(1) # First-order differencing
first_diff_c = first_diff_c.dropna(inplace = False)
test_stationarity(first_diff_c, window = 12)

bic_matrix = []
for p in [0,1,9]:
    temp= []
    for q in [0,1,9]:
        try:
            temp.append(ARIMA(closes, (p, 1, q)).fit().bic)
        except:
            temp.append(None)
    bic_matrix.append(temp)

bic_matrix = pd.DataFrame(bic_matrix)  
p,q = bic_matrix.stack().idxmin()  
print(u'BIC 最小的p值 和 q 值：%s,%s' %(p,q))

bic_matrix

fig = plt.figure(figsize=(12,8))
ax1=fig.add_subplot(211)
fig = sm.graphics.tsa.plot_acf(first_diff_c,lags=20,ax=ax1)
ax2 = fig.add_subplot(212)
fig = sm.graphics.tsa.plot_pacf(first_diff_c,lags=20,ax=ax2)
plt.show()

# Fit ARIMA model
arima_mod_a = ARIMA(closes, order=(0,1,1)).fit(disp=False)
print(arima_mod_a.summary())

residual_plot(arima_mod_a)

from datetime import datetime
end = datetime(2022, 3, 1)
start = datetime(2021, 11, 13)
duration = end-start
print(duration.days)

predict_d = arima_mod_a.forecast(109)[0] # Predict until 1st March 2022
print(predict_d)

pidx = pd.date_range(start,end,freq='d').to_series()
print(pidx)

predict_DF = pd.DataFrame(predict_d)
predict_DF.set_index(pidx, inplace=True)
predict_DF

fig, ax = plt.subplots(figsize=(12, 8))
closes = train['Close']
ax = closes.plot(ax=ax)
predict_DF.plot(ax=ax)
# fig = arima_mod_a.plot_predict(start=datetime(2021,11,13), end=datetime(2022,3,1), dynamic=True, ax=ax, plot_insample=False)
plt.legend(['Known', 'ARIMA(0,1,1) Prediction'])
plt.show()